<?php

namespace App\Services;

use App\Models\Chat;
use App\Models\Message;
use App\Models\TelegramUser;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Hash;

class TelegramService
{
    protected string $botToken;
    protected string $apiUrl;
    protected string $botUsername;
    protected string $webhookUrl;

    public function __construct()
    {
        $this->botToken = config('services.telegram.bot_token');
        $this->apiUrl = "https://api.telegram.org/bot{$this->botToken}";
        $this->botUsername = config('services.telegram.bot_username');
        $this->webhookUrl = config('services.telegram.webhook_url');

        if (empty($this->botToken)) {
            Log::error('Telegram bot token is not set');
        }
    }

    /**
     * –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ Telegram
     */
    public function sendMessage(int $chatId, string $text, array $options = []): array
    {
        if (empty($this->botToken)) {
            return [
                'success' => false,
                'message' => 'Bot token is not set'
            ];
        }

        try {
            $response = Http::post("{$this->apiUrl}/sendMessage", array_merge([
                'chat_id' => $chatId,
                'text' => $text,
                'parse_mode' => 'HTML',
            ], $options));

            $result = $response->json();

            if ($result['ok']) {
                return [
                    'success' => true,
                    'message' => 'Message sent successfully'
                ];
            }

            Log::error('Failed to send message', ['error' => $result['description']]);
            return [
                'success' => false,
                'message' => $result['description']
            ];
        } catch (\Exception $e) {
            Log::error('Error sending message: ' . $e->getMessage());
            return [
                'success' => false,
                'message' => 'Error sending message'
            ];
        }
    }

    /**
     * –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤–µ–±—Ö—É–∫–∞
     */
    public function setWebhook(): array
    {
        if (empty($this->botToken)) {
            return [
                'success' => false,
                'message' => 'Bot token is not set'
            ];
        }

        try {
            $response = Http::post("{$this->apiUrl}/setWebhook", [
                'url' => $this->webhookUrl
            ]);

            $result = $response->json();

            if ($result['ok']) {
                Log::info('Webhook set successfully', ['url' => $this->webhookUrl]);
                return [
                    'success' => true,
                    'message' => 'Webhook set successfully'
                ];
            }

            Log::error('Failed to set webhook', ['error' => $result['description']]);
            return [
                'success' => false,
                'message' => $result['description']
            ];
        } catch (\Exception $e) {
            Log::error('Error setting webhook: ' . $e->getMessage());
            return [
                'success' => false,
                'message' => 'Error setting webhook'
            ];
        }
    }

    /**
     * –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –≤–µ–±—Ö—É–∫–µ
     */
    public function getWebhookInfo(): array
    {
        try {
            $response = Http::get("{$this->apiUrl}/getWebhookInfo");
            return $response->json();
        } catch (\Exception $e) {
            Log::error('Get Webhook Info Error', [
                'message' => $e->getMessage(),
            ]);

            return ['ok' => false, 'error' => $e->getMessage()];
        }
    }

    /**
     * –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏
     */
    public function getWebAppInfo(): array
    {
        try {
            $response = Http::get("{$this->apiUrl}/getWebAppInfo");
            return $response->json();
        } catch (\Exception $e) {
            Log::error('Get WebApp Info Error', [
                'message' => $e->getMessage(),
            ]);

            return ['ok' => false, 'error' => $e->getMessage()];
        }
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–Ω–Ω—ã—Ö –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
     */
    public function validateWebAppData(string $initData): bool
    {
        try {
            $response = Http::post("{$this->apiUrl}/validateWebAppData", [
                'init_data' => $initData,
            ]);

            return $response->json()['ok'] ?? false;
        } catch (\Exception $e) {
            Log::error('Validate WebApp Data Error', [
                'message' => $e->getMessage(),
            ]);

            return false;
        }
    }

    /**
     * –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ö–æ–¥—è—â–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
     */
    public function handleMessage(array $update): void
    {
        try {
            $message = $update['message'] ?? null;
            if (!$message) {
                return;
            }

            // –°–æ–∑–¥–∞–Ω–∏–µ –∏–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            $telegramUser = $this->createOrUpdateTelegramUser($message['from']);

            // –°–æ–∑–¥–∞–Ω–∏–µ –∏–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —á–∞—Ç–∞
            $chat = $this->createOrUpdateChat($message['chat']);

            // –°–æ–∑–¥–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è
            $this->createMessage($message, $telegramUser, $chat);

            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥
            if (isset($message['text']) && str_starts_with($message['text'], '/')) {
                $this->handleCommand($message['text'], $telegramUser, $chat);
            }
        } catch (\Exception $e) {
            Log::error('Handle Message Error', [
                'message' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);
        }
    }

    /**
     * –°–æ–∑–¥–∞–Ω–∏–µ –∏–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è Telegram
     */
    protected function createOrUpdateTelegramUser(array $userData): TelegramUser
    {
        return TelegramUser::updateOrCreate(
            ['telegram_id' => $userData['id']],
            [
                'username' => $userData['username'] ?? null,
                'first_name' => $userData['first_name'] ?? null,
                'last_name' => $userData['last_name'] ?? null,
                'language_code' => $userData['language_code'] ?? null,
                'is_bot' => $userData['is_bot'] ?? false,
            ]
        );
    }

    /**
     * –°–æ–∑–¥–∞–Ω–∏–µ –∏–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —á–∞—Ç–∞
     */
    protected function createOrUpdateChat(array $chatData): Chat
    {
        return Chat::updateOrCreate(
            ['telegram_id' => $chatData['id']],
            [
                'type' => $chatData['type'],
                'title' => $chatData['title'] ?? null,
                'username' => $chatData['username'] ?? null,
                'first_name' => $chatData['first_name'] ?? null,
                'last_name' => $chatData['last_name'] ?? null,
            ]
        );
    }

    /**
     * –°–æ–∑–¥–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è
     */
    protected function createMessage(array $messageData, TelegramUser $telegramUser, Chat $chat): Message
    {
        return Message::create([
            'telegram_id' => $messageData['message_id'],
            'text' => $messageData['text'] ?? null,
            'date' => date('Y-m-d H:i:s', $messageData['date']),
            'telegram_user_id' => $telegramUser->id,
            'chat_id' => $chat->id,
            'reply_to_message_id' => $messageData['reply_to_message']['message_id'] ?? null,
            'is_command' => isset($messageData['text']) && str_starts_with($messageData['text'], '/'),
        ]);
    }

    /**
     * –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥
     */
    protected function handleCommand(string $command, TelegramUser $telegramUser, Chat $chat): void
    {
        $command = strtolower(trim($command, '/'));
        $webAppUrl = config('services.telegram.web_app_url');
        
        switch ($command) {
            case 'start':
                $keyboard = [
                    'inline_keyboard' => [
                        [
                            [
                                'text' => 'üöÄ –û—Ç–∫—Ä—ã—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ',
                                'web_app' => ['url' => $webAppUrl]
                            ]
                        ],
                        [
                            [
                                'text' => '‚ùì –ü–æ–º–æ—â—å',
                                'callback_data' => 'help'
                            ]
                        ]
                    ]
                ];

                $this->sendMessage($chat->telegram_id, 
                    "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!\n\n".
                    "–Ø –≤–∞—à –±–æ—Ç-–ø–æ–º–æ—â–Ω–∏–∫. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ.",
                    ['reply_markup' => json_encode($keyboard)]
                );
                break;

            case 'help':
                $keyboard = [
                    'inline_keyboard' => [
                        [
                            [
                                'text' => 'üöÄ –û—Ç–∫—Ä—ã—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ',
                                'web_app' => ['url' => $webAppUrl]
                            ]
                        ]
                    ]
                ];

                $this->sendMessage($chat->telegram_id, 
                    "üìù –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n\n".
                    "/start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º\n".
                    "/help - –ü–æ–∫–∞–∑–∞—Ç—å —Å–ø—Ä–∞–≤–∫—É\n".
                    "/app - –û—Ç–∫—Ä—ã—Ç—å –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ\n\n".
                    "–¢–∞–∫–∂–µ –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞ –∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—é:",
                    ['reply_markup' => json_encode($keyboard)]
                );
                break;

            case 'app':
                if ($webAppUrl) {
                    $keyboard = [
                        'inline_keyboard' => [
                            [
                                [
                                    'text' => 'üöÄ –û—Ç–∫—Ä—ã—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ',
                                    'web_app' => ['url' => $webAppUrl]
                                ]
                            ]
                        ]
                    ];

                    $this->sendMessage($chat->telegram_id, 
                        "üåê –ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ:",
                        ['reply_markup' => json_encode($keyboard)]
                    );
                } else {
                    $this->sendMessage($chat->telegram_id, '‚ö†Ô∏è –í–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ.');
                }
                break;

            default:
                $keyboard = [
                    'inline_keyboard' => [
                        [
                            [
                                'text' => '‚ùì –ü–æ–º–æ—â—å',
                                'callback_data' => 'help'
                            ]
                        ]
                    ]
                ];

                $this->sendMessage($chat->telegram_id, 
                    "‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞.\n\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /help –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–æ–º–∞–Ω–¥.",
                    ['reply_markup' => json_encode($keyboard)]
                );
                break;
        }
    }

    public function webhook($update)
    {
        try {
            if (isset($update['message'])) {
                $this->handleMessage($update);
                return ['ok' => true];
            } 
            
            if (isset($update['callback_query'])) {
                $this->handleCallbackQuery($update['callback_query']);
                return ['ok' => true];
            }

            Log::warning('Unhandled update type', ['update' => $update]);
            return ['ok' => true];
        } catch (\Exception $e) {
            Log::error('Webhook error: ' . $e->getMessage());
            return ['ok' => false, 'error' => $e->getMessage()];
        }
    }

    protected function handleCallbackQuery($callbackQuery)
    {
        try {
            $user = $this->getOrCreateUser($callbackQuery['from']);
            $message = $callbackQuery['message'];
            $data = $callbackQuery['data'];

            // –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –æ callback-–∑–∞–ø—Ä–æ—Å–µ
            Message::create([
                'user_id' => $user->id,
                'chat_id' => $message['chat']['id'],
                'message_id' => $message['message_id'],
                'text' => $data,
                'type' => 'callback',
                'data' => json_encode($callbackQuery)
            ]);

            // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä–∞–∑–ª–∏—á–Ω—ã–µ callback-–∑–∞–ø—Ä–æ—Å—ã
            switch ($data) {
                case 'help':
                    $webAppUrl = config('services.telegram.web_app_url');
                    $keyboard = [
                        'inline_keyboard' => [
                            [
                                [
                                    'text' => 'üöÄ –û—Ç–∫—Ä—ã—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ',
                                    'web_app' => ['url' => $webAppUrl]
                                ]
                            ]
                        ]
                    ];

                    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç –Ω–∞ callback-–∑–∞–ø—Ä–æ—Å
                    Http::post("{$this->apiUrl}/answerCallbackQuery", [
                        'callback_query_id' => $callbackQuery['id'],
                        'text' => '–û—Ç–∫—Ä—ã–≤–∞—é —Å–ø—Ä–∞–≤–∫—É...'
                    ]);

                    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å–æ —Å–ø—Ä–∞–≤–∫–æ–π
                    $this->sendMessage($message['chat']['id'], 
                        "üìù –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n\n".
                        "/start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º\n".
                        "/help - –ü–æ–∫–∞–∑–∞—Ç—å —Å–ø—Ä–∞–≤–∫—É\n".
                        "/app - –û—Ç–∫—Ä—ã—Ç—å –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ\n\n".
                        "–¢–∞–∫–∂–µ –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞ –∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—é:",
                        ['reply_markup' => json_encode($keyboard)]
                    );
                    break;

                default:
                    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç –Ω–∞ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π callback-–∑–∞–ø—Ä–æ—Å
                    Http::post("{$this->apiUrl}/answerCallbackQuery", [
                        'callback_query_id' => $callbackQuery['id'],
                        'text' => '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞'
                    ]);
                    break;
            }
        } catch (\Exception $e) {
            Log::error('Error handling callback query: ' . $e->getMessage());
            
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç –æ–± –æ—à–∏–±–∫–µ
            try {
                Http::post("{$this->apiUrl}/answerCallbackQuery", [
                    'callback_query_id' => $callbackQuery['id'],
                    'text' => '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞',
                    'show_alert' => true
                ]);
            } catch (\Exception $e) {
                Log::error('Error sending callback answer: ' . $e->getMessage());
            }
        }
    }

    protected function getOrCreateUser($userData)
    {
        return TelegramUser::firstOrCreate(
            ['telegram_id' => $userData['id']],
            [
                'username' => $userData['username'] ?? null,
                'first_name' => $userData['first_name'] ?? null,
                'last_name' => $userData['last_name'] ?? null,
                'language_code' => $userData['language_code'] ?? null,
            ]
        );
    }

    protected function getOrCreateChat($chatData)
    {
        return Chat::firstOrCreate(
            ['telegram_id' => $chatData['id']],
            [
                'type' => $chatData['type'],
                'title' => $chatData['title'] ?? null,
                'username' => $chatData['username'] ?? null,
                'first_name' => $chatData['first_name'] ?? null,
                'last_name' => $chatData['last_name'] ?? null,
            ]
        );
    }

    public function validateInitData($initData)
    {
        try {
            $data = [];
            parse_str($initData, $data);
            
            if (!isset($data['hash'])) {
                return false;
            }

            $hash = $data['hash'];
            unset($data['hash']);

            ksort($data);
            $dataString = http_build_query($data);
            
            $secretKey = hash('sha256', $this->botToken, true);
            $calculatedHash = hash_hmac('sha256', $dataString, $secretKey);

            return hash_equals($hash, $calculatedHash);
        } catch (\Exception $e) {
            Log::error('Error validating init data: ' . $e->getMessage());
            return false;
        }
    }

    public function getUserFromInitData($initData)
    {
        try {
            $data = [];
            parse_str($initData, $data);
            
            if (!isset($data['user'])) {
                return null;
            }

            return json_decode($data['user'], true);
        } catch (\Exception $e) {
            Log::error('Error getting user from init data: ' . $e->getMessage());
            return null;
        }
    }
} 